# 泛型

## 什么是泛型

软件工程中，不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。

而使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样就可以以不同的数据类型来使用组件。

## 泛型的使用

虽然使用 `any` 类型后能接收任何类型的参数，但是却丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。

因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 `类型变量`，它是一种特殊的变量，只用于表示类型而不是值。

```ts
function identity<T>(arg: T): T {
  return arg;
}
let output = identity<string>('Hello World!');
```

`identity` 函数会返回任何传入它的值。给 `identity` 添加了类型变量 `T` 。 `T` 可以捕获传入的类型（比如：`number`），之后就可以使用这个类型，再次使用了 `T` 当做返回值类型。参数类型与返回值类型就是相同的了。这允许我们跟踪函数里使用的类型的信息。

这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了`<>`括起来而不是`()`。

第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：

```ts
let output = identity("myString");
```

注意我们没必要使用尖括号`<>`来明确地传入类型；编译器可以查看 `myString` 的值，然后把 `T` 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 `T` 的类型，在一些复杂的情况下，这是可能出现的。

我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。

```ts
function extend<S, N>(first: S, second: N): S | N {
  return Math.random() > 0.5 ? first : second;
}
extend<string, number>('ok', 15);
```